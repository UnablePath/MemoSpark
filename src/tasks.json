{
  "tasks": [
    {
      "id": "51834695-3dca-41d4-8598-beb7384b5025",
      "name": "Task 1: Redesign and Re-implement Mascot Component",
      "description": "The current KoalaMascot component and its SVG have presented display and potential complexity issues. This task is to **completely redesign or significantly simplify the mascot SVG and re-implement the React component from the ground up**. The goal is optimal display, scalability, performance, and strict adherence to project standards. **Do not merely patch existing problems; a full rebuild is required to ensure robustness and prevent future issues.**",
      "notes": "This is a critical task to improve UI consistency and performance. The user explicitly requested a full redo, not a patch. Focus on quality and adherence to standards. No shortcuts.",
      "status": "completed",
      "dependencies": [],
      "createdAt": "2025-06-02T18:02:04.896Z",
      "updatedAt": "2025-06-02T20:04:31.409Z",
      "relatedFiles": [
        {
          "path": "src/components/ui/koala-mascot.tsx",
          "type": "TO_MODIFY",
          "description": "Completely redesigned and reimplemented KoalaMascot component"
        },
        {
          "path": "src/components/home/GamifiedReminderTab.tsx",
          "type": "TO_MODIFY",
          "description": "Update usage to use Tailwind sizing classes instead of size prop"
        },
        {
          "path": "src/components/tasks/StuTaskGuidance.tsx",
          "type": "TO_MODIFY",
          "description": "Update usage to use Tailwind sizing classes instead of size prop"
        },
        {
          "path": "src/components/tasks/StuPreferences.tsx",
          "type": "TO_MODIFY",
          "description": "Update usage to use Tailwind sizing classes instead of size prop"
        },
        {
          "path": "public/Koala GUY.svg",
          "type": "REFERENCE",
          "description": "Original complex SVG source that was causing issues - replaced with simplified design"
        }
      ],
      "implementationGuide": "1. **Analyze & Document Issues:** Thoroughly examine the existing SVG in `src/components/ui/koala-mascot.tsx`. Document specific complexities, rendering artifacts, and scaling problems. \n2. **SVG Redesign/Simplification:** Based on the analysis, either redesign a new, simpler SVG for the mascot or drastically simplify the existing one using an SVG editor. Prioritize clean paths, a proper `viewBox` for intrinsic scaling, and removal of any elements that hinder performance or scalability, while retaining the mascot's core identity. Optimize the SVG for web usage. \n3. **Component Re-implementation (from scratch):** Create a new `KoalaMascot.tsx` (or overwrite with a completely new implementation). It must be a React functional component using TypeScript. \n4. **Props & Styling:** The component should primarily use Tailwind CSS classes passed via the `className` prop for sizing (e.g., `w-16 h-16`, `w-24 h-24`) to ensure consistency with the project's styling conventions and enable responsive design. If absolutely necessary for dynamic sizing not achievable with Tailwind, a `size` prop (numeric or predefined strings like 'sm', 'md', 'lg') could be considered, but Tailwind utility classes are preferred. Ensure SVG parts use `currentColor` for fills/strokes where appropriate to inherit text color, or use CSS variables if needed. **Avoid inline styles.** \n5. **Performance & Accessibility:** Ensure the SVG is optimized and the component is performant. Include appropriate ARIA attributes (`role='img'`, `aria-labelledby` referencing a `<title>` element within the SVG). \n6. **Integration & Verification:** Replace all existing usages of the old mascot component (e.g., in `GamifiedReminderTab.tsx`, `StuTaskGuidance.tsx`, `StuPreferences.tsx`) with the new one. **Rigorously test** in all contexts to confirm correct display, crisp scaling at various sizes/resolutions, absence of rendering artifacts, and no negative performance impact. **Verify that this from-the-ground-up rework resolves previous sizing and display complaints comprehensively.**",
      "verificationCriteria": "Mascot component is completely re-implemented. The SVG is optimized and displays crisply and correctly at all required sizes and resolutions. No rendering artifacts. The component is performant, accessible, and uses Tailwind CSS for styling/sizing as per project standards. All previous display issues are comprehensively resolved. The solution is a full rework, not a patch.",
      "analysisResult": "The overarching goal is a **comprehensive and high-quality rework** of the entire task and event input system. This includes: \n1.  A complete redesign and re-implementation of the mascot component for optimal display, scalability, and performance â€“ **do not just patch existing issues; rebuild from the ground up**.\n2.  Ensuring the task/event system is fully functional, highly intuitive, and robustly cloud-synced with Supabase. **No cutting corners**; prioritize clean architecture and maintainability.\n3.  Leveraging Supabase (including Supabase MCP tools where applicable for migrations, queries, and potentially Edge Functions) for all backend operations and data persistence.\n4.  Employing React Query (or SWR) for efficient server state management, focusing on performance and avoiding unnecessary re-renders. Hooks like `useEffect` should be used judiciously and correctly, not as a default for all side effects.\n5.  Improving AI suggestions for diversity and relevance through better contextual data and potentially a feedback loop.\n6.  Strict adherence to all project UI styles (Shadcn/Tailwind) and development standards (React, Next.js, TypeScript best practices).\n7.  Centralizing all type definitions and ensuring meticulous error handling and clear loading states throughout the application.\n**Performance is paramount; avoid solutions that could slow down the application.**",
      "summary": "Task completed successfully. The KoalaMascot component has been completely redesigned and reimplemented from scratch with the official Stu head-only SVG design. The new implementation uses the optimized SVG provided by the user, eliminates all performance issues from the original 32KB complex SVG, properly implements Tailwind CSS-based sizing through className prop instead of deprecated size prop, maintains accessibility with proper ARIA labels and semantic markup, uses proper TypeScript interfaces, and all five component files that use the mascot have been successfully updated to use the new API (GamifiedReminderTab, StuTaskGuidance, StuPreferences, WidgetContent, DraggableWidget, and RemindersTab).",
      "completedAt": "2025-06-02T20:04:31.406Z"
    },
    {
      "id": "f1060777-c847-4cb1-bf21-8ad0138c62bc",
      "name": "Task 2: Backend Foundation - Supabase Schema & RLS",
      "description": "Define and implement the Supabase database schema for `tasks` and `timetable_entries`. **This must be done meticulously, considering all data types and constraints.** Implement robust Row Level Security (RLS) policies. Use Supabase MCP tools for applying migrations.",
      "notes": "This is the critical backend foundation. Thoroughness is key. Do not proceed without verifying RLS works as expected.",
      "status": "pending",
      "dependencies": [],
      "createdAt": "2025-06-02T18:02:04.896Z",
      "updatedAt": "2025-06-02T18:02:04.896Z",
      "relatedFiles": [
        {
          "path": "supabase/migrations/",
          "type": "CREATE",
          "description": "New SQL migration file for tasks and timetable_entries tables and RLS policies."
        },
        {
          "path": "src/types/taskTypes.ts",
          "type": "CREATE",
          "description": "Centralized TypeScript type definitions to guide schema."
        }
      ],
      "implementationGuide": "1. **Type Definition First:** Create/update `src/types/taskTypes.ts` with precise TypeScript interfaces for `Task`, `TimetableEntry`, and any related enums (e.g., `Priority`, `TaskType`). These types will guide schema creation. \n2. **Migration Script Creation:** In `supabase/migrations/`, create a new SQL migration file. Define `CREATE TABLE` statements for `tasks` and `timetable_entries`. Schema for `tasks`: `id` (UUID, PK), `user_id` (UUID, FK to `auth.users.id`, not null), `title` (TEXT, not null), `description` (TEXT), `due_date` (TIMESTAMPZ), `priority` (TEXT, ideally an ENUM type if Supabase project settings allow easy enum creation, else TEXT with check constraint: 'low', 'medium', 'high'), `type` (TEXT, check constraint: 'academic', 'personal', 'event'), `subject` (TEXT), `completed` (BOOLEAN, default false, not null), `reminder_settings` (JSONB), `recurrence_rule` (TEXT, for iCalendar RRULEs), `original_due_date` (TIMESTAMPZ, for recurring instances), `created_at` (TIMESTAMPZ, default `now()`), `updated_at` (TIMESTAMPZ, default `now()`). Schema for `timetable_entries`: `id` (UUID, PK), `user_id` (UUID, FK to `auth.users.id`, not null), `course_name` (TEXT, not null), `course_code` (TEXT), `instructor` (TEXT), `location` (TEXT), `start_time` (TIME), `end_time` (TIME), `days_of_week` (TEXT[]), `semester_start_date` (DATE), `semester_end_date` (DATE), `color` (TEXT), `created_at` (TIMESTAMPZ, default `now()`), `updated_at` (TIMESTAMPZ, default `now()`). \n3. **Indexes & Constraints:** Add `NOT NULL` where appropriate. Create indexes on `user_id` for both tables and potentially on `due_date` for `tasks`. \n4. **RLS Policies:** For both tables, implement RLS policies: Enable RLS. Create policies for `SELECT`, `INSERT`, `UPDATE`, `DELETE` ensuring users can only operate on their own data (`user_id = auth.uid()`). **No shortcuts on RLS; security is paramount.** \n5. **Apply Migrations:** Use the Supabase CLI (or VS Code extension if integrated) to apply the migration (`supabase db push` or `supabase migration up`). **Verify successful application using Supabase MCP if possible, or Studio.** \n6. **Triggers for `updated_at`:** Implement database triggers to automatically update the `updated_at` column on any row update for both tables.",
      "verificationCriteria": "`tasks` and `timetable_entries` tables are created in Supabase with the correct, detailed schema. RLS policies are implemented correctly and prevent unauthorized data access. All constraints and indexes are in place. `updated_at` triggers function correctly. Migration applied successfully.",
      "analysisResult": "The overarching goal is a **comprehensive and high-quality rework** of the entire task and event input system. This includes: \n1.  A complete redesign and re-implementation of the mascot component for optimal display, scalability, and performance â€“ **do not just patch existing issues; rebuild from the ground up**.\n2.  Ensuring the task/event system is fully functional, highly intuitive, and robustly cloud-synced with Supabase. **No cutting corners**; prioritize clean architecture and maintainability.\n3.  Leveraging Supabase (including Supabase MCP tools where applicable for migrations, queries, and potentially Edge Functions) for all backend operations and data persistence.\n4.  Employing React Query (or SWR) for efficient server state management, focusing on performance and avoiding unnecessary re-renders. Hooks like `useEffect` should be used judiciously and correctly, not as a default for all side effects.\n5.  Improving AI suggestions for diversity and relevance through better contextual data and potentially a feedback loop.\n6.  Strict adherence to all project UI styles (Shadcn/Tailwind) and development standards (React, Next.js, TypeScript best practices).\n7.  Centralizing all type definitions and ensuring meticulous error handling and clear loading states throughout the application.\n**Performance is paramount; avoid solutions that could slow down the application.**"
    },
    {
      "id": "b2892621-6cb8-4852-9e03-5c48e08dc04e",
      "name": "Task 3: Data Access Layer - Supabase Client & React Query",
      "description": "Implement a robust data access layer using the Supabase client library and React Query for server state management. **Focus on creating efficient, performant, and well-typed query/mutation functions. Avoid unnecessary `useEffect` calls for data fetching.**",
      "notes": "This layer is crucial for decoupling UI from data fetching logic and ensuring performance and maintainability. **Hard code adherence to React Query best practices.**",
      "status": "pending",
      "dependencies": [
        {
          "taskId": "f1060777-c847-4cb1-bf21-8ad0138c62bc"
        }
      ],
      "createdAt": "2025-06-02T18:02:04.896Z",
      "updatedAt": "2025-06-02T18:02:04.896Z",
      "relatedFiles": [
        {
          "path": "src/lib/supabase/tasksApi.ts",
          "type": "CREATE",
          "description": "Typed service functions for task and timetable CRUD using Supabase client."
        },
        {
          "path": "src/hooks/useTaskQueries.ts",
          "type": "CREATE",
          "description": "Custom React Query hooks for task operations."
        },
        {
          "path": "src/hooks/useTimetableQueries.ts",
          "type": "CREATE",
          "description": "Custom React Query hooks for timetable operations."
        },
        {
          "path": "src/lib/supabase/client.ts",
          "type": "REFERENCE",
          "description": "Supabase client initialization file."
        },
        {
          "path": "src/types/taskTypes.ts",
          "type": "REFERENCE",
          "description": "Reference to centralized TypeScript types."
        }
      ],
      "implementationGuide": "1. **React Query Setup:** Ensure React Query (`@tanstack/react-query`) and its devtools are correctly set up in the project. \n2. **Supabase Client:** Verify a singleton Supabase client instance is available (e.g., from `src/lib/supabase/client.ts`). \n3. **API Service Functions:** Create `src/lib/supabase/tasksApi.ts` (or similar). Implement strongly-typed async functions for all CRUD operations on `tasks` and `timetable_entries`. Example task functions: `fetchTasks(): Promise<Task[]>`, `getTaskById(id: string): Promise<Task | null>`, `createTask(taskData: Omit<Task, 'id' | 'created_at' | 'updated_at' | 'user_id'>): Promise<Task>`, `updateTask(id: string, updates: Partial<Task>): Promise<Task>`, `deleteTask(id: string): Promise<void>`. Similar functions for timetable entries. These functions will use the Supabase JS client. **Ensure efficient queries; select only necessary columns.** \n4. **React Query Hooks:** Create custom hooks abstracting React Query logic (e.g., in `src/hooks/useTaskQueries.ts`, `src/hooks/useTimetableQueries.ts`). Examples: `useFetchTasks()`, `useCreateTask()`, `useUpdateTask()`, `useDeleteTask()`. These hooks will call the API service functions. Implement query invalidation and optimistic updates where appropriate for a smooth UX. **Handle loading and error states comprehensively within these hooks or ensure they are exposed for UI components to handle.** \n5. **Type Safety:** Ensure all functions and hooks are fully typed using the definitions from `src/types/taskTypes.ts`. \n6. **Performance:** Design queries to be efficient. Fetch only data needed for the current view. `useEffect` should NOT be used for triggering data fetches managed by React Query; rely on query keys and React Query's lifecycle.",
      "verificationCriteria": "All CRUD operations for tasks and timetable entries are implemented via typed service functions and React Query hooks. Data is fetched efficiently. Hooks correctly manage server state, including loading, error, and data states. Optimistic updates and query invalidation are implemented where beneficial. No incorrect `useEffect` usage for data fetching.",
      "analysisResult": "The overarching goal is a **comprehensive and high-quality rework** of the entire task and event input system. This includes: \n1.  A complete redesign and re-implementation of the mascot component for optimal display, scalability, and performance â€“ **do not just patch existing issues; rebuild from the ground up**.\n2.  Ensuring the task/event system is fully functional, highly intuitive, and robustly cloud-synced with Supabase. **No cutting corners**; prioritize clean architecture and maintainability.\n3.  Leveraging Supabase (including Supabase MCP tools where applicable for migrations, queries, and potentially Edge Functions) for all backend operations and data persistence.\n4.  Employing React Query (or SWR) for efficient server state management, focusing on performance and avoiding unnecessary re-renders. Hooks like `useEffect` should be used judiciously and correctly, not as a default for all side effects.\n5.  Improving AI suggestions for diversity and relevance through better contextual data and potentially a feedback loop.\n6.  Strict adherence to all project UI styles (Shadcn/Tailwind) and development standards (React, Next.js, TypeScript best practices).\n7.  Centralizing all type definitions and ensuring meticulous error handling and clear loading states throughout the application.\n**Performance is paramount; avoid solutions that could slow down the application.**"
    },
    {
      "id": "98744547-e4c6-42af-bfd9-9c359c198e76",
      "name": "Task 4: UI Shell - TaskEventHub & Core Forms Structure",
      "description": "Develop the main `TaskEventHub.tsx` client component as the shell for the new UI. Create the structural foundation for `TaskForm.tsx` and `TimetableEntryForm.tsx`, ensuring they are wired to the new data layer for basic submission (detailed fields and validation come later). **Prioritize clean structure and adherence to project component patterns.**",
      "notes": "This task establishes the main UI container and form shells. Full form complexity and view rendering are subsequent tasks. The old `TaskEventTab.tsx` can be referenced for UI elements but the logic and state management will be entirely new.",
      "status": "pending",
      "dependencies": [
        {
          "taskId": "b2892621-6cb8-4852-9e03-5c48e08dc04e"
        }
      ],
      "createdAt": "2025-06-02T18:02:04.896Z",
      "updatedAt": "2025-06-02T18:02:04.896Z",
      "relatedFiles": [
        {
          "path": "src/components/tasks/TaskEventHub.tsx",
          "type": "CREATE",
          "description": "Main client component shell for views and forms."
        },
        {
          "path": "src/components/tasks/TaskForm.tsx",
          "type": "CREATE",
          "description": "Initial structure for task creation/editing form."
        },
        {
          "path": "src/components/tasks/TimetableEntryForm.tsx",
          "type": "CREATE",
          "description": "Initial structure for timetable entry form."
        },
        {
          "path": "src/components/ui/dialog.tsx",
          "type": "REFERENCE",
          "description": "Shadcn Dialog component."
        },
        {
          "path": "src/hooks/useTaskQueries.ts",
          "type": "REFERENCE",
          "description": "Reference to task mutation hooks."
        },
        {
          "path": "src/hooks/useTimetableQueries.ts",
          "type": "REFERENCE",
          "description": "Reference to timetable mutation hooks."
        },
        {
          "path": "src/types/taskTypes.ts",
          "type": "REFERENCE",
          "description": "Reference to TypeScript types."
        }
      ],
      "implementationGuide": "1. **Create `TaskEventHub.tsx`:** This will be the central client component in `src/components/tasks/`. It will manage the active view (list, calendar, timetable) and the open/closed state of task/timetable forms (e.g., using Shadcn Dialog). \n2. **View Switching Logic:** Implement basic state and buttons within `TaskEventHub.tsx` to switch between different view placeholders (actual view components will be integrated later). \n3. **Create `TaskForm.tsx`:** Initial structure. Include basic input fields (e.g., title, due_date for tasks) using Shadcn UI components. Wire up a submit handler that calls the `useCreateTask` and `useUpdateTask` mutation hooks from `useTaskQueries.ts`. **Focus on the wiring, not full field set yet.** \n4. **Create `TimetableEntryForm.tsx`:** Similar initial structure for timetable entries, wired to `useCreateTimetableEntry` and `useUpdateTimetableEntry` hooks. \n5. **Dialog Integration:** Use Shadcn `Dialog` component within `TaskEventHub` to host `TaskForm` and `TimetableEntryForm`. Manage dialog open/close state. \n6. **Data Flow:** Ensure that submitting a form correctly calls the mutation hook, and on success, React Query's cache invalidation (configured in the hooks) eventually updates any displayed data (even if it's just a console log or basic list for now). \n7. **Styling:** Use Tailwind CSS and adhere to project standards. **No cutting corners on component structure or file organization.**",
      "verificationCriteria": "`TaskEventHub.tsx` is created and manages view state and form dialogs. `TaskForm.tsx` and `TimetableEntryForm.tsx` have basic structures and can submit data successfully to create/update entries via React Query hooks. Data flow for mutations is functional. Code is clean and follows standards.",
      "analysisResult": "The overarching goal is a **comprehensive and high-quality rework** of the entire task and event input system. This includes: \n1.  A complete redesign and re-implementation of the mascot component for optimal display, scalability, and performance â€“ **do not just patch existing issues; rebuild from the ground up**.\n2.  Ensuring the task/event system is fully functional, highly intuitive, and robustly cloud-synced with Supabase. **No cutting corners**; prioritize clean architecture and maintainability.\n3.  Leveraging Supabase (including Supabase MCP tools where applicable for migrations, queries, and potentially Edge Functions) for all backend operations and data persistence.\n4.  Employing React Query (or SWR) for efficient server state management, focusing on performance and avoiding unnecessary re-renders. Hooks like `useEffect` should be used judiciously and correctly, not as a default for all side effects.\n5.  Improving AI suggestions for diversity and relevance through better contextual data and potentially a feedback loop.\n6.  Strict adherence to all project UI styles (Shadcn/Tailwind) and development standards (React, Next.js, TypeScript best practices).\n7.  Centralizing all type definitions and ensuring meticulous error handling and clear loading states throughout the application.\n**Performance is paramount; avoid solutions that could slow down the application.**"
    },
    {
      "id": "a61f903b-3a4b-42dd-ad35-bf36df01fb3b",
      "name": "Task 5: Implement List View",
      "description": "Develop the `ListView.tsx` component to display tasks (and events) from Supabase. Implement sorting, filtering (by completion, type, priority), and completion toggle. **Ensure the view is performant with potentially many items and offers a clean, intuitive user experience. No shortcuts on UI quality.**",
      "notes": "This view is fundamental for task management. It must be robust and user-friendly.",
      "status": "pending",
      "dependencies": [
        {
          "taskId": "98744547-e4c6-42af-bfd9-9c359c198e76"
        }
      ],
      "createdAt": "2025-06-02T18:02:04.896Z",
      "updatedAt": "2025-06-02T18:02:04.896Z",
      "relatedFiles": [
        {
          "path": "src/components/tasks/ListView.tsx",
          "type": "CREATE",
          "description": "List view component implementation."
        },
        {
          "path": "src/components/tasks/TaskEventHub.tsx",
          "type": "TO_MODIFY",
          "description": "Integrate ListView into TaskEventHub."
        },
        {
          "path": "src/hooks/useTaskQueries.ts",
          "type": "REFERENCE",
          "description": "Hook for fetching and updating tasks."
        },
        {
          "path": "src/types/taskTypes.ts",
          "type": "REFERENCE",
          "description": "Task type definitions."
        },
        {
          "path": "@/components/ui/card.tsx",
          "type": "REFERENCE",
          "description": "Shadcn Card component."
        },
        {
          "path": "@/components/ui/table.tsx",
          "type": "REFERENCE",
          "description": "Shadcn Table component (if used)."
        }
      ],
      "implementationGuide": "1. **Create `ListView.tsx`:** This client component will fetch tasks using `useFetchTasks()` from `useTaskQueries.ts`. \n2. **Display Logic:** Render tasks using Shadcn `Card` components or a well-structured table. Display key information: title, due date (formatted), priority, type, subject, completion status. \n3. **Completion Toggle:** Implement a checkbox or button for each task to toggle its `completed` status. This should call the `useUpdateTask` mutation. Ensure optimistic updates for a smooth UX. \n4. **Sorting:** Implement client-side sorting controls (e.g., dropdowns) for due date, priority, and title. \n5. **Filtering:** Implement client-side filtering controls for completion status, task type (academic, personal, event), and priority. \n6. **Performance:** If lists can be very long, consider virtualization (`@tanstack/react-virtual`) to maintain performance. **Avoid rendering all items if not visible.** \n7. **Loading & Empty States:** Implement clear loading skeletons/spinners (using Shadcn components) and a user-friendly message for empty states (no tasks). \n8. **Styling & UX:** Adhere to Tailwind CSS and project design standards. Ensure the list is easy to scan and interact with. **Do not compromise on UI polish.**",
      "verificationCriteria": "List view correctly displays tasks from Supabase, reflecting real-time updates from mutations. Task completion can be toggled. Sorting and filtering functions correctly and intuitively. The view is performant, handles loading/empty states gracefully, and is visually polished.",
      "analysisResult": "The overarching goal is a **comprehensive and high-quality rework** of the entire task and event input system. This includes: \n1.  A complete redesign and re-implementation of the mascot component for optimal display, scalability, and performance â€“ **do not just patch existing issues; rebuild from the ground up**.\n2.  Ensuring the task/event system is fully functional, highly intuitive, and robustly cloud-synced with Supabase. **No cutting corners**; prioritize clean architecture and maintainability.\n3.  Leveraging Supabase (including Supabase MCP tools where applicable for migrations, queries, and potentially Edge Functions) for all backend operations and data persistence.\n4.  Employing React Query (or SWR) for efficient server state management, focusing on performance and avoiding unnecessary re-renders. Hooks like `useEffect` should be used judiciously and correctly, not as a default for all side effects.\n5.  Improving AI suggestions for diversity and relevance through better contextual data and potentially a feedback loop.\n6.  Strict adherence to all project UI styles (Shadcn/Tailwind) and development standards (React, Next.js, TypeScript best practices).\n7.  Centralizing all type definitions and ensuring meticulous error handling and clear loading states throughout the application.\n**Performance is paramount; avoid solutions that could slow down the application.**"
    },
    {
      "id": "23718d7c-1ec7-4feb-b316-dd0a383260c1",
      "name": "Task 6: Implement Calendar View",
      "description": "Develop `CalendarView.tsx`. Integrate a robust calendar library (e.g., FullCalendar) to display tasks/events. Allow day selection to view details. **Focus on a clean integration and user-friendly presentation. Ensure performance even with many events.**",
      "notes": "A functional and visually appealing calendar is key. Drag-and-drop for rescheduling is a potential future enhancement but not in scope for this initial task unless trivial with the chosen library.",
      "status": "pending",
      "dependencies": [
        {
          "taskId": "98744547-e4c6-42af-bfd9-9c359c198e76"
        }
      ],
      "createdAt": "2025-06-02T18:02:04.896Z",
      "updatedAt": "2025-06-02T18:02:04.896Z",
      "relatedFiles": [
        {
          "path": "src/components/tasks/CalendarView.tsx",
          "type": "CREATE",
          "description": "Calendar view component implementation."
        },
        {
          "path": "src/components/tasks/TaskEventHub.tsx",
          "type": "TO_MODIFY",
          "description": "Integrate CalendarView into TaskEventHub."
        },
        {
          "path": "src/hooks/useTaskQueries.ts",
          "type": "REFERENCE",
          "description": "Hook for fetching tasks."
        },
        {
          "path": "src/types/taskTypes.ts",
          "type": "REFERENCE",
          "description": "Task type definitions."
        }
      ],
      "implementationGuide": "1. **Library Selection & Setup:** Choose and install a calendar library. FullCalendar (`@fullcalendar/react`, `@fullcalendar/daygrid`, `@fullcalendar/timegrid`, `@fullcalendar/interaction`) is highly recommended for its features. \n2. **Create `CalendarView.tsx`:** This client component will use `useFetchTasks()`. \n3. **Data Transformation:** Transform fetched tasks/events into the event format required by the chosen calendar library. Map fields like title, dueDate (start/end times), and potentially color based on task priority or type. \n4. **Calendar Rendering:** Configure the calendar to display events. Implement navigation (month/week/day views if desired). \n5. **Interaction:** Clicking on a day or event should ideally open a modal/sidebar (managed by `TaskEventHub` or locally) showing details or allowing quick editing of tasks for that day/event. For now, displaying task titles for a selected day is a minimum. \n6. **Styling:** Customize the calendar's appearance using its theming options or CSS overrides to match the project's Tailwind/Shadcn style. **Ensure a seamless visual integration; do not leave default library styles if they clash.** \n7. **Performance:** Ensure the calendar handles a reasonable number of events performantly. Leverage the library's event fetching capabilities if it supports dynamic loading for large date ranges. \n8. **Loading/Empty States:** Display appropriate loading indicators while tasks are fetched.",
      "verificationCriteria": "Calendar view displays tasks/events from Supabase correctly. Users can navigate the calendar. Selecting a day shows relevant task information. The calendar is styled to match the application theme and performs well.",
      "analysisResult": "The overarching goal is a **comprehensive and high-quality rework** of the entire task and event input system. This includes: \n1.  A complete redesign and re-implementation of the mascot component for optimal display, scalability, and performance â€“ **do not just patch existing issues; rebuild from the ground up**.\n2.  Ensuring the task/event system is fully functional, highly intuitive, and robustly cloud-synced with Supabase. **No cutting corners**; prioritize clean architecture and maintainability.\n3.  Leveraging Supabase (including Supabase MCP tools where applicable for migrations, queries, and potentially Edge Functions) for all backend operations and data persistence.\n4.  Employing React Query (or SWR) for efficient server state management, focusing on performance and avoiding unnecessary re-renders. Hooks like `useEffect` should be used judiciously and correctly, not as a default for all side effects.\n5.  Improving AI suggestions for diversity and relevance through better contextual data and potentially a feedback loop.\n6.  Strict adherence to all project UI styles (Shadcn/Tailwind) and development standards (React, Next.js, TypeScript best practices).\n7.  Centralizing all type definitions and ensuring meticulous error handling and clear loading states throughout the application.\n**Performance is paramount; avoid solutions that could slow down the application.**"
    },
    {
      "id": "5b88809d-6811-40ad-b37b-30ccf88a5c68",
      "name": "Task 7: Implement Timetable View",
      "description": "Develop `TimetableView.tsx`, potentially by refactoring/reusing `TimetableGrid.tsx`. Display class schedules fetched from Supabase. **The view must be clear, easy to read, and accurately reflect the user's timetable. Ensure data consistency with forms.**",
      "notes": "This view is for the user's static class schedule. Ensure it correctly reflects data managed via `TimetableEntryForm.tsx`.",
      "status": "pending",
      "dependencies": [
        {
          "taskId": "98744547-e4c6-42af-bfd9-9c359c198e76"
        }
      ],
      "createdAt": "2025-06-02T18:02:04.896Z",
      "updatedAt": "2025-06-02T18:02:04.896Z",
      "relatedFiles": [
        {
          "path": "src/components/tasks/TimetableView.tsx",
          "type": "CREATE",
          "description": "Timetable view component implementation."
        },
        {
          "path": "src/components/tasks/TimetableGrid.tsx",
          "type": "REFERENCE",
          "description": "Existing grid component, to be refactored or its logic reused."
        },
        {
          "path": "src/components/tasks/TaskEventHub.tsx",
          "type": "TO_MODIFY",
          "description": "Integrate TimetableView into TaskEventHub."
        },
        {
          "path": "src/hooks/useTimetableQueries.ts",
          "type": "REFERENCE",
          "description": "Hook for fetching timetable entries."
        },
        {
          "path": "src/types/taskTypes.ts",
          "type": "REFERENCE",
          "description": "TimetableEntry type definitions."
        }
      ],
      "implementationGuide": "1. **Create `TimetableView.tsx`:** This client component will use `useFetchTimetableEntries()` from `useTimetableQueries.ts`. \n2. **Grid Logic:** Refactor or adapt the logic from the existing `src/components/tasks/TimetableGrid.tsx` to display timetable entries. The grid should clearly show course name, time, location (if available), and day of the week. \n3. **Data Display:** Populate the grid with fetched timetable entries. Use colors if defined in the entries for better visual distinction. \n4. **Interaction:** Clicking a timetable entry could show more details (e.g., instructor, full course code) in a popover or sidebar. Allow triggering the edit form for an entry. \n5. **Empty State:** Provide a clear message and perhaps a CTA to add entries if the timetable is empty. \n6. **Styling:** Ensure the timetable is visually clean, easy to parse, and responsive. Use Tailwind CSS. **No clunky UI will be accepted.**",
      "verificationCriteria": "Timetable view accurately displays class schedules from Supabase. Data is well-formatted and easy to read. Interactions (if any beyond display) are smooth. Empty state is handled. UI is polished.",
      "analysisResult": "The overarching goal is a **comprehensive and high-quality rework** of the entire task and event input system. This includes: \n1.  A complete redesign and re-implementation of the mascot component for optimal display, scalability, and performance â€“ **do not just patch existing issues; rebuild from the ground up**.\n2.  Ensuring the task/event system is fully functional, highly intuitive, and robustly cloud-synced with Supabase. **No cutting corners**; prioritize clean architecture and maintainability.\n3.  Leveraging Supabase (including Supabase MCP tools where applicable for migrations, queries, and potentially Edge Functions) for all backend operations and data persistence.\n4.  Employing React Query (or SWR) for efficient server state management, focusing on performance and avoiding unnecessary re-renders. Hooks like `useEffect` should be used judiciously and correctly, not as a default for all side effects.\n5.  Improving AI suggestions for diversity and relevance through better contextual data and potentially a feedback loop.\n6.  Strict adherence to all project UI styles (Shadcn/Tailwind) and development standards (React, Next.js, TypeScript best practices).\n7.  Centralizing all type definitions and ensuring meticulous error handling and clear loading states throughout the application.\n**Performance is paramount; avoid solutions that could slow down the application.**"
    },
    {
      "id": "72f25e2a-3db1-479b-800e-fbc67b0b0938",
      "name": "Task 8: Implement Recurrence Logic",
      "description": "Implement UI for defining recurrence rules (iCalendar RRULE standard) in `TaskForm.tsx`. Develop logic to correctly generate and display recurring task instances in `ListView.tsx` and `CalendarView.tsx`. **This is a complex feature; approach methodically and test thoroughly. Prioritize correctness of instance generation.**",
      "notes": "Correctly handling time zones with recurrence can be tricky; ensure date-fns or similar is used consistently. **No shortcuts on testing the edge cases for recurrence rules.**",
      "status": "pending",
      "dependencies": [
        {
          "taskId": "a61f903b-3a4b-42dd-ad35-bf36df01fb3b"
        },
        {
          "taskId": "23718d7c-1ec7-4feb-b316-dd0a383260c1"
        }
      ],
      "createdAt": "2025-06-02T18:02:04.896Z",
      "updatedAt": "2025-06-02T18:02:04.896Z",
      "relatedFiles": [
        {
          "path": "src/components/tasks/TaskForm.tsx",
          "type": "TO_MODIFY",
          "description": "Add UI for defining recurrence rules."
        },
        {
          "path": "src/components/tasks/ListView.tsx",
          "type": "TO_MODIFY",
          "description": "Implement logic to display recurring task instances."
        },
        {
          "path": "src/components/tasks/CalendarView.tsx",
          "type": "TO_MODIFY",
          "description": "Implement logic to display recurring task instances."
        },
        {
          "path": "src/types/taskTypes.ts",
          "type": "TO_MODIFY",
          "description": "Ensure Task type accommodates RRULE string and original due date for master."
        },
        {
          "path": "src/lib/supabase/tasksApi.ts",
          "type": "TO_MODIFY",
          "description": "Ensure recurrence rule is saved/fetched correctly."
        }
      ],
      "implementationGuide": "1. **RRULE Library:** Install and use `rrule.js` for parsing and generating dates from RRULE strings. \n2. **TaskForm UI for Recurrence:** Extend `TaskForm.tsx` with UI elements (e.g., Shadcn Select, DatePicker) for users to define recurrence: frequency (daily, weekly, monthly, yearly), interval, days of the week (for weekly), day of the month (for monthly), end date or count. Store the generated RRULE string in the task's `recurrence_rule` field. \n3. **Instance Generation Logic:** In `ListView.tsx` and `CalendarView.tsx` (or helper functions they use), when displaying tasks for a given date range, iterate through tasks with `recurrence_rule`. Use `rrule.js` to generate instances within the view's date range. Each instance should inherit properties from the master task but have its specific `dueDate`. The `original_due_date` field in the `tasks` table (master task's original due date) can help identify instances. \n4. **Displaying Instances:** Ensure recurring instances are visually distinct (e.g., with an icon) and display their correct instance date. \n5. **Editing/Deleting Recurrences (Basic):** For this phase, focus on correct display. Editing/deleting might initially only apply to the master task (affecting all instances). Handling individual instance changes is a more advanced feature for later. **Define clearly what level of edit/delete (master vs instance) is being implemented.** \n6. **Performance:** Be mindful of performance when generating many instances, especially for long date ranges or highly frequent recurrences. Consider limiting the forward range of instance generation for display purposes.",
      "verificationCriteria": "Users can define various recurrence patterns for tasks in the form. Recurring task instances are correctly generated and displayed in both List and Calendar views for the visible time period. Basic modification (e.g. editing the master task) works as expected. Instance generation is reasonably performant.",
      "analysisResult": "The overarching goal is a **comprehensive and high-quality rework** of the entire task and event input system. This includes: \n1.  A complete redesign and re-implementation of the mascot component for optimal display, scalability, and performance â€“ **do not just patch existing issues; rebuild from the ground up**.\n2.  Ensuring the task/event system is fully functional, highly intuitive, and robustly cloud-synced with Supabase. **No cutting corners**; prioritize clean architecture and maintainability.\n3.  Leveraging Supabase (including Supabase MCP tools where applicable for migrations, queries, and potentially Edge Functions) for all backend operations and data persistence.\n4.  Employing React Query (or SWR) for efficient server state management, focusing on performance and avoiding unnecessary re-renders. Hooks like `useEffect` should be used judiciously and correctly, not as a default for all side effects.\n5.  Improving AI suggestions for diversity and relevance through better contextual data and potentially a feedback loop.\n6.  Strict adherence to all project UI styles (Shadcn/Tailwind) and development standards (React, Next.js, TypeScript best practices).\n7.  Centralizing all type definitions and ensuring meticulous error handling and clear loading states throughout the application.\n**Performance is paramount; avoid solutions that could slow down the application.**"
    },
    {
      "id": "c7c6ff87-f684-4fdf-9e38-891f7893e98a",
      "name": "Task 9: Enhance AI Suggestions",
      "description": "Improve AI task suggestions in `AITaskSuggestions.tsx` for greater diversity and relevance. Implement a user feedback mechanism (thumbs up/down) and use more comprehensive context from Supabase. **The goal is genuinely helpful and varied suggestions, not just placeholders.**",
      "notes": "This requires careful thought about what context is useful and how feedback can realistically influence the AI. **Do not implement a superficial feedback system; it must have a tangible impact on suggestion quality.**",
      "status": "pending",
      "dependencies": [
        {
          "taskId": "b2892621-6cb8-4852-9e03-5c48e08dc04e"
        }
      ],
      "createdAt": "2025-06-02T18:02:04.896Z",
      "updatedAt": "2025-06-02T18:02:04.896Z",
      "relatedFiles": [
        {
          "path": "src/components/tasks/AITaskSuggestions.tsx",
          "type": "TO_MODIFY",
          "description": "Main component for AI suggestions; needs context and feedback UI."
        },
        {
          "path": "src/lib/ai/index.ts",
          "type": "REFERENCE",
          "description": "`StudySparkAI` class, may need modification to accept/use feedback."
        },
        {
          "path": "src/lib/ai/suggestionEngine.ts",
          "type": "REFERENCE",
          "description": "Core suggestion logic, may need review for diversity and feedback integration."
        },
        {
          "path": "supabase/migrations/",
          "type": "CREATE",
          "description": "Migration for `ai_suggestion_feedback` table if not already created."
        },
        {
          "path": "src/lib/supabase/tasksApi.ts",
          "type": "TO_MODIFY",
          "description": "Add functions to save AI suggestion feedback to Supabase."
        }
      ],
      "implementationGuide": "1. **Context Enhancement:** In `AITaskSuggestions.tsx`, modify the `SuggestionContext`. Fetch relevant data from Supabase, such as a summary of the user's recently completed tasks, upcoming task types, or even timetable entries for the day, to provide richer, more personalized context to the AI suggestion engine (`StudySparkAI`). **Use performant queries via React Query hooks created in Task 3.** \n2. **Feedback Mechanism UI:** For each displayed suggestion, add simple thumbs up/down buttons. \n3. **Feedback Storage (Supabase):** Create a new Supabase table (e.g., `ai_suggestion_feedback`) with fields like `id`, `user_id`, `suggestion_id` (if suggestions have unique IDs from the AI), `suggestion_type`, `feedback` (e.g., 'liked', 'disliked'), `timestamp`. When a user gives feedback, store it here. This may require a new migration and RLS. **Use Supabase MCP tools to manage this.** \n4. **Leverage Feedback in AI Logic:** Modify the AI suggestion generation logic (this might be in `StudySparkAI.generateIntelligentSuggestions` or its calling functions) to consider this feedback. For example, if a user frequently dislikes a certain type of suggestion, deprioritize it. This might involve sending feedback summaries to the AI model if it's an LLM, or adjusting client-side ranking algorithms. \n5. **Diversity & Caching:** Review the existing suggestion caching mechanism in `AITaskSuggestions.tsx`. If the cache key is too broad or lifetime too long, it might contribute to repetition. Consider making the cache more granular or adding mechanisms to introduce variety even with cached elements (e.g., rotating through a set of valid suggestions for a similar context). \n6. **Fallback Suggestions:** Ensure fallback suggestions (if AI fails) are also context-aware and varied.",
      "verificationCriteria": "AI suggestions are noticeably more diverse and contextually relevant based on improved context and user feedback. The feedback mechanism (UI and storage) is functional. Changes to caching or suggestion logic demonstrably reduce repetition. The system feels more intelligent and helpful.",
      "analysisResult": "The overarching goal is a **comprehensive and high-quality rework** of the entire task and event input system. This includes: \n1.  A complete redesign and re-implementation of the mascot component for optimal display, scalability, and performance â€“ **do not just patch existing issues; rebuild from the ground up**.\n2.  Ensuring the task/event system is fully functional, highly intuitive, and robustly cloud-synced with Supabase. **No cutting corners**; prioritize clean architecture and maintainability.\n3.  Leveraging Supabase (including Supabase MCP tools where applicable for migrations, queries, and potentially Edge Functions) for all backend operations and data persistence.\n4.  Employing React Query (or SWR) for efficient server state management, focusing on performance and avoiding unnecessary re-renders. Hooks like `useEffect` should be used judiciously and correctly, not as a default for all side effects.\n5.  Improving AI suggestions for diversity and relevance through better contextual data and potentially a feedback loop.\n6.  Strict adherence to all project UI styles (Shadcn/Tailwind) and development standards (React, Next.js, TypeScript best practices).\n7.  Centralizing all type definitions and ensuring meticulous error handling and clear loading states throughout the application.\n**Performance is paramount; avoid solutions that could slow down the application.**"
    },
    {
      "id": "d801787a-901f-4021-a334-cc8cb96e07f3",
      "name": "Task 10: Final Polish, Integration, and Rigorous Testing",
      "description": "Perform a final, meticulous round of UI/UX polishing across all new/modified task and event components. Ensure seamless integration, consistent styling, optimal performance, and responsiveness. **Conduct comprehensive testing of all features from the ground up. No regressions allowed. This is not a quick check; it's a deep validation.**",
      "notes": "This final phase is critical to deliver a high-quality, production-ready feature. **Treat this as a dedicated QA and refinement sprint. No cutting corners on testing or polish.**",
      "status": "pending",
      "dependencies": [
        {
          "taskId": "51834695-3dca-41d4-8598-beb7384b5025"
        },
        {
          "taskId": "72f25e2a-3db1-479b-800e-fbc67b0b0938"
        },
        {
          "taskId": "c7c6ff87-f684-4fdf-9e38-891f7893e98a"
        }
      ],
      "createdAt": "2025-06-02T18:02:04.896Z",
      "updatedAt": "2025-06-02T18:02:04.896Z",
      "relatedFiles": [
        {
          "path": "src/components/tasks/",
          "type": "TO_MODIFY",
          "description": "All components within this directory are subject to final review and polish."
        },
        {
          "path": "src/app/dashboard/",
          "type": "TO_MODIFY",
          "description": "Ensure the page hosting the task management system is fully polished and integrated."
        },
        {
          "path": "src/components/ui/koala-mascot.tsx",
          "type": "REFERENCE",
          "description": "Verify final mascot integration."
        }
      ],
      "implementationGuide": "1. **Component Review:** Go through every component created or modified in this revamp (`TaskEventHub`, views, forms, `KoalaMascot`, `AITaskSuggestions`). Check for adherence to all project standards (TypeScript, React, Next.js, Tailwind, naming, imports). \n2. **UI/UX Polish:** Refine all visual details. Ensure consistent spacing, typography, colors. Check for smooth transitions and animations (use `framer-motion` appropriately, respecting reduced motion). **Eliminate any remaining 'clunky' feel.** \n3. **Responsiveness:** Test thoroughly on various screen sizes (desktop, tablet, mobile). Ensure layouts adapt correctly and all functionality remains accessible. \n4. **Performance Audit:** Profile the application, especially the new task/event views. Identify and fix any performance bottlenecks. Ensure efficient rendering and data handling. **The app must not feel slow.** \n5. **Error Handling:** Verify that all error states (API errors, form validation errors, etc.) are handled gracefully and provide clear feedback to the user. \n6. **End-to-End Testing:** Test all user flows: \n    - Creating, viewing, editing, deleting tasks and timetable entries (including recurring ones). \n    - Switching between list, calendar, and timetable views. \n    - AI suggestion generation and feedback. \n    - Cloud synchronization (verify data persistence and consistency across sessions/devices by checking Supabase). \n    - Mascot display in all its contexts. \n7. **Cross-browser Testing (Basic):** Test on latest versions of major browsers (Chrome, Firefox, Safari, Edge). \n8. **Code Cleanup:** Remove any dead code, console logs, or temporary workarounds. Ensure all code is well-documented where necessary.",
      "verificationCriteria": "The entire reworked task and event system is fully functional, highly intuitive, performant, visually polished, and responsive. All user-reported issues are comprehensively addressed. Data syncs reliably with Supabase. AI suggestions are improved. Mascot is perfect. No regressions or new bugs. The system meets all specified quality standards and is ready for users.",
      "analysisResult": "The overarching goal is a **comprehensive and high-quality rework** of the entire task and event input system. This includes: \n1.  A complete redesign and re-implementation of the mascot component for optimal display, scalability, and performance â€“ **do not just patch existing issues; rebuild from the ground up**.\n2.  Ensuring the task/event system is fully functional, highly intuitive, and robustly cloud-synced with Supabase. **No cutting corners**; prioritize clean architecture and maintainability.\n3.  Leveraging Supabase (including Supabase MCP tools where applicable for migrations, queries, and potentially Edge Functions) for all backend operations and data persistence.\n4.  Employing React Query (or SWR) for efficient server state management, focusing on performance and avoiding unnecessary re-renders. Hooks like `useEffect` should be used judiciously and correctly, not as a default for all side effects.\n5.  Improving AI suggestions for diversity and relevance through better contextual data and potentially a feedback loop.\n6.  Strict adherence to all project UI styles (Shadcn/Tailwind) and development standards (React, Next.js, TypeScript best practices).\n7.  Centralizing all type definitions and ensuring meticulous error handling and clear loading states throughout the application.\n**Performance is paramount; avoid solutions that could slow down the application.**"
    }
  ]
}